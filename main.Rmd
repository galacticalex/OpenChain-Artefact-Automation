---
title: "OpenChain Compliance Automation"
author: "Alexander Murphy"
date: "`r Sys.Date()`"
output:
  pdf_document: default
  html_document: default
subtitle: Automating the generation of OpenChain compliance artefacts
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## OpenChain

International standard (ISO/IEC 5230) lists requirements for a quality open source licence compliance program. The project homepage is here: https://www.openchainproject.org/; and the specificaiton and workgroup manage the development publicly on GitHub here: https://github.com/OpenChain-Project/License-Compliance-Specification.

The standard provides the following definition: 

> 2.1 - compliance artifacts
a collection of artifacts that represent the output of a compliance program and accompany the supplied software
> 
> Note: The collection may include (but is not limited to) one or more of the following: attribution notices, source code, build and install scripts, copy of licenses, copyright notices, modification notifications, written offers, open source component bill of materials, and SPDX documents.

These data are what we will automate in this demonstration (attribution notices and licence texts specifically, other artefacts may be required but this is not an exhaustive exercise, regardless, it is highly unlikely that the steps in this example will map exactly to your own use-case).

## Tools

OpenChain is a non-prescriptive standard. To (ab)use computer science terminology, OpenChain is declarative in nature, it tells you *what* to do, but you decide *how* to go about it. This example is a generalised method (rather, a collection of tools and processes) used frequently at Orcro to generate compliance artefacts.

### Spelling

Artefacts - British engligh, artifacts, american english. Former used throughout.

### Scancode toolkit

Our favorite OSS SCA tool (https://github.com/nexB/scancode-toolkit). Fully featured, well supported, active community. Straightforward to integrate into existing pipelines (run Python script direct from the repo).

Runs comprehensive battery of regex patterns on source code for licence/copyright matches. Huge test suite. 

### R

Statistical computing programming language. This is the author's personal preference (a dark art) although Python would work, and bash scripts would also work. No libraries are required, just Base R.

### Scripts

These are the "glue" that holds togheter the pipeline. These will all be written in R.

### Git

The code we review will be located in a Git repository. *this* repo (OpenChain...) contains a submodule to our demonstration project, OpenBLAS (more on this project below).

## Overview

We begin by identifying what data we need to automate. This step is usually resource-intensive, so an arbitrary (and vetted) software product will be used for this example.

Then we break-down the full pipeline into "components", and semi-manually run these to illustrate what the tools are doing. I.e., we run through producing the compliance artefacts once step-by-step, and see what happens when we run a "generate compliance artefacts" command in CI.

The output of the process (the compliance artefacts) will be shown. These will be in the form of plain text files, which can be compressed if required.

## Setting expectations

Implementing the process on a CI system is not covered. 

This only covers generation of compliance artefacts for the application itself. It is likely that additional FOSS is used in any shipped product (Docker container, GPU drivers, etc.) but this process is for the application layer only.

We won't consider legal requirements, such as how the jurisdiction your code is shipped to may affect your obligations.

We won't consider engineer considerations, such as caching SCA results.

## The sample project

### OpenBLAS

BLAS (basic linear algebra subprograms) is a widely used library for matrix and vector calculations. It's open source, the reference implementation (from https://www.netlib.org/blas/) isn't "licensed" per se, rather it has some unusual wording about being free to use but to add notices if anything is modified and to provide acknowledgement for the authors.

OpenBLAS has the BSD-3-Clause out-licence, and the full source (which we look at here) is available on GitHub (https://github.com/xianyi/OpenBLAS). We consider the compiled code where no additional third-party libraries have been included via `cmake`.

## Identifying the requried artefacts

### Questions to ask

What is *distributed*?

Are there any *dependencies*?

*How* will the code be shipped?

Are there any *snippets* present?

In this case, all of the source code is provided in this monorepo. We can run our tools here without requiring any additional downloads.

Recall that build tools won't end up in the distributed binary, therefore you have no need to concern yourselves with licences for them (typically, but never seen a case where this is not the case).

Licences are BSD-3-Clause, therefore our obligations are simply: Provide copyright notices (all of them!) and the licence text. * another obligation is to not use the name of the project in marketing, but this does not impact the compliance artefacts r.e. openchain

We also see that it doesn't matter whether the code is distributed as source or in binary form. The artefacts are required* note that if distributed as source code, then the compliance materials *will be provided automatically as they are contained within the source itself!*

For this we assume the binary is distributed, and providing source code is unsuitable for some reason.

Note: providing the full source code for components licensed permissively is not *required* but it may be one way to comply! Although, if you have more than one component with different obligations then things can get messy quickly, hence, automation...

## Initial SCA

It is prudent to manually run a SCA before implementing any automation. Like shopping for bug-spray, it is important to know *what will work* before spending any money (or developer time, resources, etc.) on the thing. It would be disastrous to implement compliance automation and a year down-the-line realise that it wasn't identifying issues appropriately (or even worse, it *was* identifying them but you didn't notice)!

Scancode can be run from the command-line. So a developer, who is working inside the development repo, can simply use:

```{bash, eval=F}
pwd
/home/demo/OpenChain-Artefact-Automation/OpenBLAS/
scancode -clp -n 18 --csv ScanOut.csv .
```

which will run scancode on the source repo. This assume that scancode has been installed (added to path) et cetera (see Appendix A for simple scancode installation instructions).

As this is the first time that we have extracted copyright information using scancode, we should take a look at the data it has provided us. It is typically of high quality, but there are sometimes things that are easy to check and verify.

There are various ways of doing this, if you run the `--csv` output format then you can even load up the data into Excel and look at it that way. Here though, we'll use R.

```{r}
copyright_data <- read.csv("ScanOut.csv") # load the scan results
licences <- unique(copyright_data$detected_license_expression_spdx) 
# summarise 'unique' licences in the dataset (so we only see one of each result)
licences # display them
```

These are SPDX IDs where one exists, or a licence reference (`LiceseRef` where there is an unknown detection).

There doesn't appear to be too much to review here, these are all permissive or variants of, except for that result of `LicenseRef-scancode-proprietary-license`. You should not be too alarmed at these results (at least in the first instance) because Scancode is quite *greedy* with its results. It will generate more false positives than omissions (it's generally better this way, as you can manually review the results, you cannot manually review what you do not know exists)!

Let's double check this result, to see how often it appears, and what is triggering this result in the scan.

```{r}
copyright_data[copyright_data$detected_license_expression_spdx == "LicenseRef-scancode-proprietary-license", ]["path"] 
# selecting results that match the expression in brackets [expression]
# and then from the results, extract the path of the file (*where* the scan found it)
```

So the proprietary license result came from the LAPACKE readme. We won't go into this now, but assume that this check went well for the purposes of this demonstration, but there are a few more notes on this in Appendix 2, including the README file itself.

It would be good practice to verify all of the licence results, at least by sample, but as everything is permissive here there's unlikely to be any major issues, *and this aligns with our expectations and understanding of OpenBLAS*, so, we'll proceed with generating the artefacts.

## Generating artefacts

Now that the scan results have been collected and reviewed for problems, we can use whatever means at our disposal to generate appropriate artefacts. This is an inherently 'wooly' statement, because it depends on the licences as to what artefacts must be provided. There are also various way in which the artefacts *could* be provided for any particular licence. What follows is appropriate for permissive licences, OpenChain compliance, and note that no source code provision is required.

Some scripts have been developed by Orcro for this particular task, and are available under Apache-2.0 for you to freely use yourselves, or to learn more about generating artefacts, if you wish: https://github.com/galacticalex/compliance-artefact-generator, they are also as a submodule in this demo repository.

We're going to use a simplified script, which takes raw scancode output and produces the files. It has no user-interface to speak of however. Let's see how it works:

```{bash, eval=F}
Rscript ScanToArtefacts.R ScanOut.csv
```

We use the `Rscript` command line tool to run the script `ScanToArtefacts.R` on the SCA data file `ScanOut.csv`. This is very simply to put into a meta-level script for automation, it may simply be pasted into a `.sh` file.

### Aside, scancode data

```{r}
names(copyright_data) # view the variables that scancode extracts
```

You can see there is quite a lot going on under-the-hood with scancode. In particular look at those `license_match*` variables. These are columns in the `.csv` output file. They report how *sure* scancode is that it has found a match. We'll simplify this analysis and assume that results are reliable (and this is typically the case).

From before, there are some scancode results that were not SPDX standard IDs, I have replaced these with appropriate data - we won't go through this now.

### Resuming

Here's a snippet of the script:

```{r, eval=F}
if (length(args) != 1) { # incorrect number of cli arguments?
    cat(errorArgsNumber)
} else if (any(artefactFileNames %in% dir())) { # any pre-existing output files?
    cat(errorFileExists)
} else if (file.exists(args)) { # does the input data exist?
    generateArtefacts()
    cat(successMessage)
} else {
    cat(errorInputMissing) # if input data doesn't exist
}
```

The `generateArtefacts()` function is key here.

```{r, eval=F}
generateArtefacts = function() {
    sca_data <- dataPrep(read.csv(args[1])) # tidy the data
    # generate the artefacts - there is some unnecessary moving of data around 
    # in memory, but this simplifies the script a bit (and it's sufficiently
    # performant anyway)
    outputFile(generateOverviewText(sca_data), "Licensing_Overview.md")
    outputFile(generateAppendixA(sca_data), "Licensing_Appendix_A.md")
    outputFile(generateAppendixB(sca_data), "Licensing_Appendix_B.md")
}
```

First, some effort is spent preparing the raw scancode data into something more reasonable. We noted earlier that scancode has a huge battery of tests, and the resulting data, while valuable, is messy. Tidying that up makes the remaining artefact generation quite simple. Here's an example of generating the licence text artefact:

```{r, eval=F}
generateAppendixA = function(tidy_data) {
    # tidying list of licences
    l <- unlist(strsplit(unlist(tidy_data$detected_license_expression_spdx), " AND "))
    l <- unique(l)
    l <- l[l != "N/A"]
    l <- l[-grep("License", l)]
    l <- gsub("[\\(|\\)]", "", l)
    
    # setup urls for downloading
    first <- rep("https://raw.githubusercontent.com/spdx/license-list-data/master/text/", length(l))
    last <- rep(".txt", length(l))
    dls <- paste0(first, l, last)
    
    # local "out" is a buffer, if one dl fails, the script will abort and may 
    # leave artefacts
    out <- appendixAText
    
    # useful info for the user
    cat("\n\n Licence texts will now be downloaded...\n\n")
    Sys.sleep(2)
    
    for (l in dls) {
        download.file(l, destfile = "licence.tmp", 
                      method = "wget", 
                      quite = TRUE)
        out = paste0(out, "\n\n--------------------\n\n", 
                     readChar("licence.tmp", file.info("licence.tmp")$size))
        file.remove("licence.tmp")
    }
    
    cat("\n\n Removing temporary files...\n\n")
    Sys.sleep(2)
    
    out
}

```

This is just one of the artefacts, we won't look at the others now. But notice that some further preparation of the data is done (which is specific for this artefact, so it makes sense to do it here) before raw licence texts are downloaded from a reputable repository. There is then some logic to concatenate all the licences in a readable format into the single artefact file. There is also some cli output to let a user know that the internet is being accessed, this can be removed if the script is used in an automated pipeline.

The entire script is only a couple hundred lines long. We extract relevant data from the SCA results, then wrangle it into a suitable output format. There are some quality of life-checks (ensuring that no data is overwritten). The file output is handled by a helper function elsewere in the script.

After running the script the working directory will contain the following files:

- Licensing_Overview.md
- Licensing_Appendix_1.md
- Licensing_Appendix_2.md

And we can view the contents of each of these files - they are in plain text. Here's the `Overview` in its entirety:

```{}
# Overview

This software contains a number of open source components. For a summary, see 
below. For the relevant licence texts, see Appendix A. For the relevant notices 
and attributions et cetera, see Appendix B.

Not all components listed may be incorporated in, or may necessarily have 
generated derivative works which are incorporated in the firmware, but were 
used during the build process.

Where a range of dates is given after a copyright notice, this should be taken 
to imply that copyright is asserted for every year within that range, inclusive 
of the years stated.

## Components and Licences

OpenBLAS - BSD-3-Clause

```

This is mostly boilerplate, but at the bottom there is a list of the components in the software. There's only one here, as we're reviewing a library with no transitive dependencies (OpenBLAS has some which you can link to, but we are assuming these are not used).

There's also the licence `Appendix`, whose generating function we looked at earlier:

```{}
# Appendix A: Licence Texts

--------------------

Copyright (c) <year> <owner>. 

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


--------------------
```

Here's the BSD-3-Clause licence, there are others in the file. And lastly, here's the head of the copyright notice artefact:

```{}
# Appendix B: Notices and Attribution

---------------

File: OpenBLAS/benchmark/amax.c
Copyright statement(s): Copyright (c) 2016, The OpenBLAS Project

---------------

File: OpenBLAS/benchmark/amin.c
Copyright statement(s): Copyright (c) 2016, The OpenBLAS Project

---------------

File: OpenBLAS/benchmark/asum.c
Copyright statement(s): Copyright (c) 2014, The OpenBLAS Project
```

We can see that each file (demarkated by lots of dashes) is noted, alongside the copyright statements that were extracted for that file. There are 

```{bash}
wc -l Licensing_Appendix_B.md
```

... quite a few records. Divide by five (each statement has surrounding whitespace, dashes, filename) and we calculate there are approximately five thousand copyright statements in OpenBLAS. 

> Note that any files which lack copyright statements are not listed. This is acceptable as BSD-3-Clause obligates you to reproduce the statements, *not* the source code

## Conclusion

We've looked at an end-to-end process for generating compliance artefacts from raw source code. Obviously this is a simplified process for this demonstration, there are countless nuances which could not possibly be documented (author's note: every time I do an analysis, there is something new). This is the challenge of automating compliance. 

The heavy lifting can be left to SCA tools and scripts, as described above. But the devil is very much in the detail with compliance, and this requires some diligent analysis, preferably in the policy stage to prevent rampant OSS code from causing licensing issues right before a deployment.

## Appendix A: Scancode installation

`cd` to the installation directory, then

```{bash, eval=F}
git clone --depth=1 https://github.com/nexB/scancode-toolkit.git
cd ./scancode
./scancode --help
```

Running `./scancode --help` will setup scancode for first use. There are other methods in the documentation (https://scancode-toolkit.readthedocs.io/en/stable/) but the above is, clearly, very simple. The above can be copied into a `.sh` script, Docker `RUN` directive, et cetera, as required.

## Appendix B: Intel's `proprietary-license` result

The full README is here:

```{bash}
cat OpenBLAS/lapack-netlib/LAPACKE/README
```

This requires some further analysis, however, it is highly likely that in the "INTEL TERMS OF SERVICE" that such code is licensed freely with the disclaimer.